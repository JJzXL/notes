事务是程序中一系列严密的操作，事务中所有的步骤全部成功执行，事务提交。如果其中一个步骤失败，将会发生回滚操作，撤销到事务开始之前的所有的操作。



**事务的四个特征**

1. 原子性(Atomicity)：事务是数据库的逻辑工作单位，事务中包含多个操作，要么都做完，要么都不做
2. 隔离性(Isolation)：事务彼此之间是不能互相干扰的，即一个事务的操作对该数据库的其他事务操作是隔离的，并发执行的各个事务时间互补干扰
3. 持久性(Durability)：事务一旦提交，其变更是永久性的，不会再发生回滚
4. 一致性(Consistency)：事务执行的结果必须满足从一个状态变到另一个状态，因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性的状态。如果数据库系统在运行时发生系统故障，有些未完成的事务被迫中止，而有一部分修改已经写入数据库，这个时候数据库就处于一种不正确的状态。



**MySQL的四种隔离级别**

1. 读取未提交的数据【Read Uncommitted】 在该隔离级别，所有的事务都可以看到其他事务没有提交的执行结果。（实际生产中不可能使用这种隔离级别的）
2. 读取提交的内容【Read Committed】 该隔离级别是大多数数据库的默认的隔离级别（不是 MySQL 默认的）。它满足了隔离的简单定义:一个事务只能看到其他的已经提交的事务所做的改变。这种隔离级别也支持不可重复读，即同一个 select 可能得到不同的结果
3. 可重读【Repeatable Read】 这是 MySQL 默认的隔离级别，它确保同一个事务在并发读取数据时，会看到同样的数据行。不过理论上会导致另外一个问题，【幻读】。幻读：相同的条件查询一些数据，然后其他事务【新增】或者是【删除】了该条件的数据，然后导致读取的结果不一样多。InnoDB 存储引擎通过多版本控制（MVCC）机制解决了该问题
4. 可串行化【serializable】 这是事务的最高隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决了幻读的问题。它在每个读的数据行上面加上共享锁，。但是可能会导致超时和锁竞争（这种隔离级别太极端，实际生产基本不使用）



**脏读、幻读、不可重复读**

1. 脏读：读取了前一个事务未提交的或者是回滚的数据
2. 不可重复读：同样的 select 查询，但是结果不同，过程中有事务更新了原有的数据
3. 幻读：两次查询的结果数量不一样，过程中有事务新增或者是删除数据

**不同隔离级别产生的不同问题**

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| Read Uncommitted | 会   | 会         | 会   |
| Read Committed   | 不会 | 会         | 会   |
| Repeatable Read  | 不会 | 不会       | 会   |
| Serializable     | 不会 | 不会       | 不会 |

