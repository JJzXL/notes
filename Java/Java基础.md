# Java基础知识

**基本类型**

<img src="../images/Java/Java基本类型.jpg" alt="Java基本类型" style="zoom:50%;" />

**自动装箱和拆箱**

```java
Integer o = 1; //装箱
int p = o; // 拆箱
```

装箱：把基本类型用他们对应的包装类型包装起来。实际上是调用的是包装类型的`valueOf()`方法。

拆箱：把包装类型转换为基本类型。实际上是调用的包装类型的`xxxValue()`方法。

Java 基本类型的包装类的大部分都实现了常量池技术。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在[0,127]范围的缓存数据，`Boolean` 直接返回 `True` Or `False`。

---

**`==`和`equals`方法**

对于基本类型'=='比较的是值，引用类型比较的是地址。equals()比较的是值

equals()是对象的方法，不能用于基本类型比较

一个类如果没有重写equals()方法，那么equals()等同于`==`

---

**hashCode()和equals()**

`hashCode()`是本地方法，作用是获取哈希码，一个int值。哈希码的作用是确定对象在哈希表中的索引位置。

**为什么重写 `equals` 时必须重写 `hashCode` 方法？**

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**

> `hashCode()`的默认行为是对堆上的对象产生独特值。如果没有重写 `hashCode()`，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

**重写`equals`方法的要求**

> 1. 对称性：如果x.equals(y)返回是"true"，那么y.equals(x)也应该返回是"true"。
> 2. 反射性：x.equals(x)必须返回是"true"。
> 3. 类推性：如果x.equals(y)返回是"true"，而且y.equals(z)返回是"true"，那么z.equals(x)也应该返回是"true"。
> 4. 一致性：如果x.equals(y)返回是"true"，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是"true"。
> 5. 非空性，x.equals(null)，永远返回是"false"；x.equals(和x不同类型的对象)永远返回是"false"。

---

**重载和重写**

| 区别点     | 重载方法                                   | 重写方法                                                     |
| ---------- | ------------------------------------------ | ------------------------------------------------------------ |
| 发生范围   | 同一个类                                   | 子类                                                         |
| 参数列表   | 参数类型、参数数量、参数顺序至少有一项不同 | 不能修改                                                     |
| 返回类型   | 可修改                                     | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改                                     | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等 |
| 访问修饰符 | 可修改                                     | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期                                     | 运行期                                                       |

---

**深拷贝 vs 浅拷贝**



---

**反射和代理**

> 获取Class对象的四种方式：
>
> 1、类名.class
>
> 2、通过 `Class.forName()`传入类的路径获取
>
> 3、通过对象实例`instance.getClass()`获取
>
> 4、通过类加载器`xxxClassLoader.loadClass()`传入类路径获取



静态代理和动态代理

1、动态代理更加灵活，不需要针为每个目标类创建一个代理类

2、从JVM层面：静态代理发生在编译时期，动态代理发生在运行时期。



JDK动态代理和CGLIB动态代理

1、JDK动态代理只能代理实现了接口的类或者接口本身，CGLIB可以代理未实现接口的类。

2、CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。

3、大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

---

